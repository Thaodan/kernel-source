From: Takashi Iwai <tiwai@suse.de>
Subject: Fix kABI incompatibility by snd_pcm_oss_runtime.rw_ref addition
Patch-mainline: Never, SLE15 only
References: bsc#1051510

The recent addition of rw_ref field to struct snd_pcm_oss_runtime
broke kABI.
Since the struct is embedded, we can't use a straightforward ifdef
trick.  Move the field to snd_pcm_runtime explicitly, and modify each
user to point to runtime->oss_rw_ref from runtime->oss.rw_ref.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 include/sound/pcm.h      |    3 +++
 include/sound/pcm_oss.h  |    1 -
 sound/core/oss/pcm_oss.c |   18 +++++++++---------
 3 files changed, 12 insertions(+), 10 deletions(-)

--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -421,6 +421,9 @@ struct snd_pcm_runtime {
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	/* -- OSS things -- */
 	struct snd_pcm_oss_runtime oss;
+#ifndef __GENKSYMS__
+	atomic_t oss_rw_ref;		/* concurrent read/write accesses */
+#endif
 #endif
 #ifndef __GENKSYMS__
 	struct mutex buffer_mutex;	/* protect for buffer changes */
--- a/include/sound/pcm_oss.h
+++ b/include/sound/pcm_oss.h
@@ -57,7 +57,6 @@ struct snd_pcm_oss_runtime {
 	char *buffer;				/* vmallocated period */
 	size_t buffer_used;			/* used length from period buffer */
 	struct mutex params_lock;
-	atomic_t rw_ref;		/* concurrent read/write accesses */
 #ifdef CONFIG_SND_PCM_OSS_PLUGINS
 	struct snd_pcm_plugin *plugin_first;
 	struct snd_pcm_plugin *plugin_last;
--- a/sound/core/oss/pcm_oss.c
+++ b/sound/core/oss/pcm_oss.c
@@ -840,7 +840,7 @@ static int lock_params(struct snd_pcm_ru
 {
 	if (mutex_lock_interruptible(&runtime->oss.params_lock))
 		return -ERESTARTSYS;
-	if (atomic_read(&runtime->oss.rw_ref)) {
+	if (atomic_read(&runtime->oss_rw_ref)) {
 		mutex_unlock(&runtime->oss.params_lock);
 		return -EBUSY;
 	}
@@ -1425,7 +1425,7 @@ static ssize_t snd_pcm_oss_write1(struct
 	if (atomic_read(&substream->mmap_count))
 		return -ENXIO;
 
-	atomic_inc(&runtime->oss.rw_ref);
+	atomic_inc(&runtime->oss_rw_ref);
 	while (bytes > 0) {
 		if (mutex_lock_interruptible(&runtime->oss.params_lock)) {
 			tmp = -ERESTARTSYS;
@@ -1489,7 +1489,7 @@ static ssize_t snd_pcm_oss_write1(struct
 		}
 		tmp = 0;
 	}
-	atomic_dec(&runtime->oss.rw_ref);
+	atomic_dec(&runtime->oss_rw_ref);
 	return xfer > 0 ? (snd_pcm_sframes_t)xfer : tmp;
 }
 
@@ -1535,7 +1535,7 @@ static ssize_t snd_pcm_oss_read1(struct
 	if (atomic_read(&substream->mmap_count))
 		return -ENXIO;
 
-	atomic_inc(&runtime->oss.rw_ref);
+	atomic_inc(&runtime->oss_rw_ref);
 	while (bytes > 0) {
 		if (mutex_lock_interruptible(&runtime->oss.params_lock)) {
 			tmp = -ERESTARTSYS;
@@ -1584,7 +1584,7 @@ static ssize_t snd_pcm_oss_read1(struct
 		}
 		tmp = 0;
 	}
-	atomic_dec(&runtime->oss.rw_ref);
+	atomic_dec(&runtime->oss_rw_ref);
 	return xfer > 0 ? (snd_pcm_sframes_t)xfer : tmp;
 }
 
@@ -1691,9 +1691,9 @@ static int snd_pcm_oss_sync(struct snd_p
 			goto __direct;
 		if ((err = snd_pcm_oss_make_ready(substream)) < 0)
 			return err;
-		atomic_inc(&runtime->oss.rw_ref);
+		atomic_inc(&runtime->oss_rw_ref);
 		if (mutex_lock_interruptible(&runtime->oss.params_lock)) {
-			atomic_dec(&runtime->oss.rw_ref);
+			atomic_dec(&runtime->oss_rw_ref);
 			return -ERESTARTSYS;
 		}
 		format = snd_pcm_oss_format_from(runtime->oss.format);
@@ -1752,7 +1752,7 @@ static int snd_pcm_oss_sync(struct snd_p
 		}
 unlock:
 		mutex_unlock(&runtime->oss.params_lock);
-		atomic_dec(&runtime->oss.rw_ref);
+		atomic_dec(&runtime->oss_rw_ref);
 		if (err < 0)
 			return err;
 		/*
@@ -2420,7 +2420,7 @@ static void snd_pcm_oss_init_substream(s
 	runtime->oss.maxfrags = 0;
 	runtime->oss.subdivision = 0;
 	substream->pcm_release = snd_pcm_oss_release_substream;
-	atomic_set(&runtime->oss.rw_ref, 0);
+	atomic_set(&runtime->oss_rw_ref, 0);
 }
 
 static int snd_pcm_oss_release_file(struct snd_pcm_oss_file *pcm_oss_file)
