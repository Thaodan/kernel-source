From: Hannes Reinecke <hare@suse.de>
Date: Thu, 16 May 2019 09:39:01 +0200
Subject: [PATCH] nvme: flush scan_work when resetting controller
Patch-Mainline: never, solved differently upstream
References: bsc#1131673

When resetting the controller there is no point whatsoever to
have a scan run in parallel; we cannot access the controller and
we cannot tell which devices are present and which not.
Additionally we'll run a scan after reset anyway.
So flush existing scans, ensuring to short-circuit the scan workqueue
function if the controller state isn't live to avoit lockups.

Signed-off-by: Hannes Reinecke <hare@suse.com>
---
 drivers/nvme/host/core.c |    7 +++++++
 drivers/nvme/host/fc.c   |    1 +
 drivers/nvme/host/rdma.c |    1 +
 3 files changed, 9 insertions(+)

--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -1640,6 +1640,9 @@ static int nvme_revalidate_disk(struct g
 		return -ENODEV;
 	}
 
+	if (ctrl->state != NVME_CTRL_LIVE)
+		return 0;
+
 	ret = nvme_identify_ns(ctrl, ns->head->ns_id, &id);
 	if (ret)
 		goto out;
@@ -3379,6 +3382,8 @@ static int nvme_scan_ns_list(struct nvme
 		return -ENOMEM;
 
 	for (i = 0; i < num_lists; i++) {
+		if (ctrl->state != NVME_CTRL_LIVE)
+			goto free;
 		ret = nvme_identify_ns_list(ctrl, prev, ns_list);
 		if (ret)
 			goto free;
@@ -3457,6 +3462,8 @@ static void nvme_scan_work(struct work_s
 	if (test_and_clear_bit(NVME_AER_NOTICE_NS_CHANGED, &ctrl->events)) {
 		dev_info(ctrl->device, "rescanning namespaces.\n");
 		nvme_clear_changed_ns_log(ctrl);
+		if (ctrl->state != NVME_CTRL_LIVE)
+			return;
 	}
 
 	if (nvme_identify_ctrl(ctrl, &id))
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@ -2965,6 +2965,7 @@ nvme_fc_reset_ctrl_work(struct work_stru
 	struct nvme_fc_ctrl *ctrl =
 		container_of(work, struct nvme_fc_ctrl, ctrl.reset_work);
 
+	flush_work(&ctrl->ctrl.scan_work);
 	nvme_stop_ctrl(&ctrl->ctrl);
 
 	/* will block will waiting for io to terminate */
--- a/drivers/nvme/host/rdma.c
+++ b/drivers/nvme/host/rdma.c
@@ -1908,6 +1908,7 @@ static void nvme_rdma_reset_ctrl_work(st
 
 	nvme_stop_ctrl(&ctrl->ctrl);
 	nvme_rdma_shutdown_ctrl(ctrl, false);
+	flush_work(&ctrl->ctrl.scan_work);
 
 	if (!nvme_change_ctrl_state(&ctrl->ctrl, NVME_CTRL_CONNECTING)) {
 		/* state change failure should never happen */
